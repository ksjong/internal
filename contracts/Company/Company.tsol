// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;
import "./Errors.tsol";
import "./Gas.tsol";
import "./Worker.tsol";
contract Company {

    uint128 MIN_BALANCE = 1 ever;

    address static owner;
    TvmCell static workerCode;

    mapping(address => bool) workers;

    uint128 salary = 132;

    uint128 totalSalaryPayed;

    event AccountDeployed(address workerAddress, address owner);
    event NewWorkerRegistered(address worker, address workerOwner);
    event SalaryPayed(address worker, uint128 salary, uint128 totalSalaryPayed);

    modifier onlyOwner() {
        require(msg.sender == owner, Errors.NOT_OWNER);
        _;
    }

    modifier onlyWorker( address _workerOwner) {
        require(getWorkerAddress(_workerOwner) == msg.sender, Errors.NOT_WORKER);
        _;
    }
//    modifier onlyRegisteredWorker() {
//        require(workers.exists(msg.sender), Errors.WORKER_NOT_REGISTERED);
//        _;
//    }

    constructor() public {
        tvm.accept();
    }

    function deployAccountForWorker() external {
        require(msg.value >= MIN_BALANCE + 0.2 ever, 101);

        tvm.rawReserve(MIN_BALANCE, 0);

        TvmCell stateInit = buildInitParams(msg.sender);

        address workerAddress = new Worker{
            stateInit: stateInit,
            code: workerCode,
            value: 1 ever
        }();
        emit AccountDeployed(workerAddress, msg.sender);
        msg.sender.transfer({value:0, flag:128});
    }

    function buildInitParams(address _accountOwner) internal returns (TvmCell){
        return tvm.buildStateInit({
            contr: Worker,
            varInit: {
                owner: _accountOwner,
                company: address(this)
            },
            pubkey: tvm.pubkey(),
            code: workerCode
        });
    }

    function getWorkerAddress(address _workerOwner) internal returns (address) {
        TvmCell workerInitState = tvm.buildStateInit({
            contr: Worker,
            varInit: {
                owner: _workerOwner,
                company: address(this)
            },
            pubkey: tvm.pubkey(),
            code: workerCode
        });

        return address(tvm.hash(workerInitState));
    }

//    function registerWorker(address _worker) public onlyOwner {
//        tvm.rawReserve(Gas.MIN_CONTRACT_BALANCE, 0);
//        Worker(_worker).acceptRegistration{value: 0, flag: 128}();
//    }

//    function finishWorkerRegistration(
//        uint256 _workerPubKey,
//        address _workerOwner
//    ) external onlyWorker(_workerPubKey, _workerOwner) {
//        tvm.rawReserve(Gas.MIN_CONTRACT_BALANCE, 0);
//        addWorkerToStore(msg.sender, _workerOwner);
//    }

//    function addWorkerToStore(
//        address _worker,
//        address _workerOwner
//    ) internal {
//        workers[msg.sender] = true;
//        emit NewWorkerRegistered(_worker, _workerOwner);
//        owner.transfer({value: 0, flag: 128});
//    }


    function doWork(
        uint256 _workerPubKey,
        address _workerOwner
    ) external onlyWorker(_workerOwner) {
        require(msg.sender == getWorkerAddress(_workerOwner), 1003);
        tvm.rawReserve(Gas.MIN_CONTRACT_BALANCE, 0);
        workProcessing(msg.sender);
    }

    function workProcessing(address _worker) internal {
        salary = salary * 2;
        totalSalaryPayed += salary;
        emit SalaryPayed(_worker, salary, totalSalaryPayed);

        //each time salary is doubled

        Worker(msg.sender).receiveSalary{value: 0, flag: 128}(salary);
    }

    function getDetails() external view returns (uint128 _salary, uint128 _totalSalaryPayed) {
        return (salary, totalSalaryPayed);
    }
}
